package Dist::Zilla::Plugin::Test::Pod::Coverage::Configurable;

use strict;
use warnings;
use namespace::autoclean;

use Data::Dumper ();
use Sub::Exporter::ForMethods;
use Data::Section 0.200002    # encoding and bytes
    { installer => Sub::Exporter::ForMethods::method_installer },
    '-setup' => { encoding => 'bytes' };
use Dist::Zilla::File::InMemory;

use Moose;

has class => (
    is      => 'ro',
    isa     => 'Str',
    default => 'Pod::Coverage::TrustPod',
);

has skip => (
    is      => 'ro',
    isa     => 'ArrayRef',
    default => sub { [] },
);

has trustme => (
    is      => 'ro',
    isa     => 'ArrayRef',
    default => sub { [] },
);

with qw(
    Dist::Zilla::Role::FileGatherer
    Dist::Zilla::Role::PrereqSource
);

sub mvp_multivalue_args {
    return qw( skip trustme );
}

# Register the release test prereq as a "develop requires"
# so it will be listed in "dzil listdeps --author"
sub register_prereqs {
    my ($self) = @_;

    $self->zilla->register_prereqs(
        {
            type  => 'requires',
            phase => 'develop',
        },
        'Test::Pod::Coverage'     => '1.08',
        'Pod::Coverage::TrustPod' => 0,
    );
}

sub gather_files {
    my ($self) = @_;

    my $content = $self->_file_content();

    $self->add_file(
        Dist::Zilla::File::InMemory->new(
            {
                name    => 'xt/release/pod-coverage.t',
                content => $content,
            }
        ),
    );

    return;
}

my $head = <<'EOF';
#!perl
# This file was automatically generated by Dist::Zilla::Plugin::Test::Pod::Coverage::Configurable.

use Test::Pod::Coverage 1.08;
use Pod::Coverage::TrustPod;
EOF

sub _file_content {
    my $self = shift;

    my $content = $head;
    $content .= 'my %skip = map { $_ => 1 } qw( '
        . ( join q{ }, @{ $self->skip() } ) . " );\n";

    my $class = $self->class();
    if ( $class ne 'Pod::Coverage::TrustPod' ) {
        $content .= <<"EOF";

{
    package
        My::Coverage;
    use parent 'Pod::Coverage::TrustPod', '$class';
}
EOF

        $class = 'My::Coverage';
    }

    $content .= <<'EOF';

my @modules = grep { ! $skip{$_} } all_modules();
plan tests => scalar @modules;
EOF

    my %trustme;
    for my $pair ( @{ $self->trustme() } ) {
        my ( $module, $regex ) = split /\s*=>\s*/, $pair;

        my $qr;

        {
            local $@;
            $qr = eval $regex;
            if ($@) {
                die "Invalid regex in trustme for $module: $regex\n  $@\n";
            }
        };

        $trustme{$module} = $qr;
    }

    if ( keys %trustme ) {
        my $trustme_dump = Data::Dumper->new( [ \%trustme ], ['*trustme'] )->Dump;
        $content .= "\nmy $trustme_dump";
    }
    else {
        $content .= "\nmy %trustme = ();\n";
    }

    $content .= <<"EOF";

for my \$module ( sort \@modules ) {
    my \@trustme;

    if ( \$trustme{\$module} ) {
        my \$methods = join '|', \@{ \$trustme{\$module} };
        \@trustme = qr/^(?:\$methods)\$/;
    }

    pod_coverage_ok(
        \$_,
        {
            coverage_class => '$class',
            trustme        => \\\@trustme,
        },
        "pod coverage for \$module"
    );
EOF

    return $content;
}

__PACKAGE__->meta->make_immutable;

1;

# ABSTRACT: dzil pod coverage tests with configurable trustme parameters

=pod

=encoding UTF-8

=head1 NAME

Dist::Zilla::Plugin::PodCoverageTests - a release test for Pod coverage

=head1 SYNOPSIS

  [Test::Pod::Coverage::Configurable]
  trustme = Dist::Some::Module => qr/^(?:foo|bar)$/
  trustme = Dist::Some::Module => qr/^foo_/
  trustme = Dist::This::Module => qr/^bar_/
  skip = Dist::Other::Module
  skip = Dist::YA::Module
  class = Pod::Coverage::Moose

=head1 DESCRIPTION

This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
following files:

  xt/release/pod-coverage.t - a Test::Pod::Coverage test

This test can be configured by providing C<trustme>, C<skip>, and C<class>
parameters in your F<dist.ini> file.

This test also uses L<Pod::Coverage::TrustPod>. This means that to indicate
that some subs should be treated as covered, even if no documentation can be
found, you can add:

  =for Pod::Coverage sub_name other_sub this_one_too

L<Test::Pod::Coverage> C<1.08> and L<Pod::Coverage::TrustPod> will be added as
C<develop requires> dependencies.

=cut
